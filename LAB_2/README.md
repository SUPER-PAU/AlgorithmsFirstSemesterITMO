# Лабораторная 2 - Сортировка слиянием
## принцип работы

- делим список на 2 части, пока не останется по одному элементу в каждой.
- Собираем список воедино из частей, путем их заполнения по порядку который нам нужен, проходясь по обоим спискам. Заполняем массив оставшимися элементами

Таким образом
- время работы алгоритма:
  - min `O(n * log(n))`
  - mid `O(n * log(n))`
  - max `O(n * log(n))`
  - `log(n)` - деление
  - `n` - рекурсивный подъем
- Затраты по памяти - `O(n)` - на хранение поделенных списков

Алгоритм
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0    
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    while i < len(left):
      result.append(left[i])
      i += 1
    while j < len(right):
      result.append(right[j])
      j += 1
    return result
```

## Задача 1
1) Необходимо реализовать сортировку слиянием.
2) Проверить наихудший/наилучший случай
3) Переписать структуру без сигнала остановки.

- Сортировка слиянием реализована.
- проверяем наихудший и наилучший случаи
  - генерируем файлы с помощью алгоритма с циклом `for` длины `10^4`
  - сравниваем работу программы:
    - худший случай: `0.1345` секунд
    - лучший случай: `0.1335` секунд
  - итог: сортировка слиянием имеет "одинаковою" временную сложность `O(n * log(n))`
- Переписываем структуру без использования сигналов для остановки
  - в реализации презентации использовались сигнальные значения `∞`, чтобы эти элементы не копировались в результирующий массив
  - я переписал без использования сигнальных значений:
    - Проверка окончания массива идёт по длине: `i < len(left)` и `j < len(right)`

## Задача 3 - Число инверсий
Инверсия - ситуация, когда `i < j`, а `A_i > A_j` - т.е. `left[i] > right[j]` 
и `i < len(left)`. Соответственно существует `len(left) - i` инверсий

- заводим глобальный счетчик и добавляем `InversionCount += len(left) - i` при `left[i] > right[j]`

## Задача 5 - Представитель большинства
Необходимо усзнать, существует ли элемент, который встречается больше, чем `n/2`
раз и вывести его если он есть. 
Необходимо использовать метод разделяй и властвуй сортировки `merge`

- используем деление на подмассивы `left` и `right` длина будет > 1
- Далее рекурсивный подъем: 
  - подсчитываем элемент, который будет чаще всего встречаться проходя по массиву
    - реализовал функцию `count_occurrences`, которая заменяет `merge`
  - если элемент подходит по условию `count > n/2`, то возвращаем его
  - если нет, то None

Итого получаем нужный элемент или `None`
  - временная скорость: `log n` на деление * `n` на подсчет наибольшего элемента в подмассивах
  - `O(log n * n)`