# Лабораторная 1 - Сортировка вставками
## принцип работы
- проходимся индексом `j` по списку, начиная с 2-го элемента списка и обзначаем этот элемент как `key`
- Берем предыдущий элемент как `i = j - 1`
- Идем индексом `i` до начала, если `i`-й элемент больше `key`
- меняем передний элемент `i + 1` на текущий `i` и двигаемся назад `i--`
- под конец меняем элемент `i + 1` на `key`.

Таким образом мы за элементом `j` всегда получаем отсортированный массив, и если встречается элемент меньше предыдущего, то "продавливаем" его назад, пока он не встанет на свое место.

- время работы алгоритма:
  - min `O(n)`
  - mid `O(n^2)`
  - max `O(n^2)`
- Затраты по памяти - `O(1)`

Алгоритм:
```python
def insertion_sort(lst):
    for j in range(1, len(lst)):
        key = lst[j]
        i = j - 1
        while i >= 0 and lst[i] > key:
            lst[i + 1] = lst[i]
            i -= 1
        lst[i + 1] = key
```

## задание 1 - отсортировать массив по insertion sort
используем функцию `insertion_sort`

## Задание 3 - Сортировка по убыванию
необходимо переписать алгоритм, чтобы он сортировал по невозрастанию. необходимо использовать `swap`.
Можно ли переписать алгоритм с использованием рекурсии?

чтобы сортировать список в обратном порядке достаточно поменять условие в условном операторе с ">" на "<", когда идем назад `i`
`while i > 0 and lst[i - 1] < lst[i]:`. Таким образом алгоритм будет менять элементы, в порядке невозрастания.

также, чтобы не возвращать ключ в конце `while` в список, можно сразу его поставить на место используя `swap`. в моем случае использовал `swap` в стиле питона.
`lst[i], lst[i - 1] = lst[i - 1], lst[i]`

Алгоритм:
```python
def insertion_sort_rev(lst):
    for j in range(1, len(lst)):
        i = j
        while i > 0 and lst[i - 1] < lst[i]:  # меняем условный оператор с ">" на "<"
            lst[i], lst[i - 1] = lst[i - 1], lst[i] # swap на python
            i -= 1
```

- можно ли использовать рекурсию? Да.
- Сортируем первые n-1 элементов рекурсивно, вместо прохода `while`
- Вставляем n-й элемент на своё место среди уже отсортированных

## Задание 6 - Пузырьковая сортировка
Напишите код на Python и докажите корректность пузырьковой сортиров-
ки.

Алгоритм сортировки:
проход по каждому элементу массива индексом `i` и вложенным циклом проход индексом `j`. Сравниваем каждый элемент `j` с элементом `i`
и меняем их.
Таким образом время работы алгоритма будет всегда `O(n^2)`, что не есть хорошо.

Алгоритм:
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1, i, -1):
            if arr[j] < arr[j - 1]:
                arr[j], arr[j - 1] = arr[j - 1], arr[j]
```

провека на длину и условие:
```python
print("Проверка на длину: " + str(len(lst_start) == len(lst)))
    flag = True
    for i in range(1, len(lst)):
        if lst[i] < lst[i - 1]:
            flag = False
            break
    print("Проверка на условие: " + str(flag))
```
Таким образом алгоритм работает также как и insertion, но в лучшем случае сортировка вставками будет быстрее, так как не будет заходить в цикл `while` и ее скорость будет `O(n)`
