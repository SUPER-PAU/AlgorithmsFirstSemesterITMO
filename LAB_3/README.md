# Лабораторная 3 - Сортировка Quick и Count
## Задание 1 - Улучшение Quick sort

Сгенерирую 6 тестов для сравнения сортировок - случаи
1) лучший (sorted) - массив размера 10000 отсортирован 
2) средний (random) - массив размера 10000 отсортирован случайным образом
3) худший (reversed) - массив размера 10000 перевернутый отсортированный массив
4) `10^3` - массив размера 10^3, с 5-ю разными числами отсортирован случайным образом
5) `10^4` - массив размера 10^4, с 5-ю разными числами отсортирован случайным образом
6) `10^5` - массив размера 10^5, с 5-ю разными числами отсортирован случайным образом


### Qsort
Алгоритм:
- Выбирается опорный элемент (pivot), чаще всего крайний элемент массива.
- Массив делится на две части: элементы меньше pivot и больше pivot.
- Сортировка вызывается рекурсивно для этих двух частей.

Время выполнения:
- `лучший` (sorted) - (Очень долгоооо.....)
- `средний` (random) - 0.1639 секунд
- `худший` (reversed) - (Очень долгоооо.....)
- `10^3` - 0.1087 секунд
- `10^4` - 71.7161 секунд
- `10^5` - (Очень долгоооо.....)

### randomized Qsort
Алгоритм:
- Вместо фиксированного pivot выбирается случайный элемент в диапазоне `[l, r]`, 
тем самым избегая худшего случая для QSort

Время выполнения:
- `лучший` (sorted) - 0.1681 секунд
- `средний` (random) - 0.1923 секунд
- `худший` (reversed) - 0.1726 секунд
- `10^3` - 0.1146 секунд
- `10^4` - 68.0449 секунд
- `10^5` - (Очень долгоооо.....)

### Partition3
Алгоритм:
- Массив делится на три части, а не на две:
  - Элементы меньше pivot
  - Элементы равные pivot
  - Элементы больше pivot
- Тем самым эффективнее предыдущих на массивах с малым кол-вом уникальных чисел,
т.к избегает лишней рекурсии для одинаковых значений (равных pivot)

Время выполнения:
- `лучший` (sorted) - 0.1967 секунд
- `средний` (random) - 0.1919 секунд
- `худший` (reversed) - 0.1946 секунд
- `10^3` - 0.0073 секунд
- `10^4` - 0.0672 секунд
- `10^5` - 0.7386 секунд

### MergeSort
Алгоритм:
- Разделяй и властвуй: Делим массив на подмассивы
- собираем их, попутно сортируя, на рекурсивном подъеме. 

Время выполнения:
- `лучший` (sorted) - 0.1342 секунд
- `средний` (random) - 0.137 секунд
- `худший` (reversed) - 0.1269 секунд
- `10^3` - 0.0089 секунд
- `10^4` - 0.1363 секунд
- `10^5` - 1.7814 секунд


### Итого:
- `StandardQuickSort` — нормальная на случайном массиве, но проваливается на отсортированных/обратных.
- `RandomizedQuickSort` — стабилен на всех наборах малого размера, особенно хорошо на отсортированных/обратных, но на больших значительно теряет эффективность.
- `Partition3` - медленней на лучшем и худшем случае в сравнении с предыдущими, но лучше всех справился с массивами мало различающихся чисел
- `MergeSort` - Лучше всех на первых 3-х тестах и чуть хуже Partition3 в массивах с мало различающимися числами


## Задание 6 - Сортировка целых чисел
В этой задаче нужно будет отсортировать много неотрицательных целых чисел.
В виде `A_i * B_j` двух массивов `A` и `В`. Вывести сумму каждых десятых чисел получившегося массива `C`.

Для этого создадим список `C = [a * b for a in A for b in B]`

Так как элементов в списке `C` может быть очень много - `6000 * 6000 = 36 000 000` необходимо использовать устойчивую 
и быструю по времени сортировку - `merge sort` (Описал алгоритм работы в [LAB_2](../LAB_2/README.md))

`C = merge_sort(C)`

Результат нужно вывести в виде суммы каждого 10-го элемента `C` - проходимся циклом по каждому 10-му эл-ту, начиная с 0-го
`result = sum(C[i] for i in range(0, len(C), 10))`


## Задание 8 - K ближайших точек
Чтобы найти `K` ближайших точек к началу координат (0, 0), использую модификацию QSort - QuickSelect.

Главная идея алгоритма заключается в том, что нам нет нужды сортировать полностью массив, его можно разделить в нужной позиции.
- Выбираем случайный опорный элемент `pivot`
- Разделяем Массив `partition()`:
  - меньше `Pivot`
  - больше `pivot`
  - Итого `pivot` остается на своей позиции в отсортированном массиве.
- Если `pivot_position == K`, то мы нашли нужный разрез `return`.
- если `>`, то ищем слева, `<` - ищем справа.
- Таким образом мы отбрасываем ненужную часть массива
- Делаем это до момента пока не `pivot_position == K`.
- Далее, чтобы вывести `К` точек в отсортированном порядке, можно применить любую эффективную сортировку массива `points[:K]`.
Я в этой задаче применил встроенную `sorted`, по функции `calc_dist`.

Полный Алгоритм
```python
import random

def calc_dist(point):
    x, y = point
    return (x ** 2) + (y ** 2)

def partition(points, left, right, pivot_index):
    pivot_distance = calc_dist(points[pivot_index])
    points[pivot_index], points[right] = points[right], points[pivot_index]
    store_index = left
    for i in range(left, right):
        if calc_dist(points[i]) < pivot_distance:
            points[store_index], points[i] = points[i], points[store_index]
            store_index += 1
    points[right], points[store_index] = points[store_index], points[right]
    return store_index

def quickselect(points, left, right, K):
    if left < right:
        pivot_index = random.randint(left, right)
        pivot_index = partition(points, left, right, pivot_index)
        if pivot_index == K:
            return
        elif pivot_index < K:
            quickselect(points, pivot_index + 1, right, K)
        else:
            quickselect(points, left, pivot_index - 1, K)

def k_closest(points, K):
    quickselect(points, 0, len(points) - 1, K)

    result = sorted(points[:K], key=calc_dist)
    return result
```


